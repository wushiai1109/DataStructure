package leetcode.editor.cn;//颠倒给定的 32 位无符号整数的二进制位。
//
// 
//
// 示例 1： 
//
// 输入: 00000010100101000001111010011100
//输出: 00111001011110000010100101000000
//解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
//     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 
//
// 示例 2： 
//
// 输入：11111111111111111111111111111101
//输出：10111111111111111111111111111111
//解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
//     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 
//
// 
//
// 提示： 
//
// 
// 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的
//还是无符号的，其内部的二进制表示形式都是相同的。 
// 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -10737418
//25。 
// 
//
// 
//
// 进阶: 
//如果多次调用这个函数，你将如何优化你的算法？ 
// Related Topics 位运算 
// 👍 216 👎 0


//leetcode submit region begin(Prohibit modification and deletion)
class 颠倒的二进制位190 {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        //1.int --> "010101" String --> reverse --> int
        //2.int --> 位运算
        //时间复杂度O(1)，没有使用循环。
        //空间复杂度O(1)，没有使用变量。
        //与反转十进制整数使用取模除十累加的方法类似，
        //十进制：ans = ans * 10 + n % 10; n = n / 10;
        //二进制：ans = ans * 2 + n % 2; n = n / 2;
        //但是，仅仅使用这种写法，会有一些问题，比如都要考虑是否整型溢出，Java的整数溢出后的二进制数会表示成负数（补码形式）,
        // Java中负数除以2会向零取整；具体可以参考这篇博客还有这个视频中: -3 / 2 = -1 而 -3 >> 1 = -2
        //然后还要考虑前导零，因为十进制是不考虑前面是否还有零的，比如100反转后就是1，不用写成001，而二进制要考虑前导零的问题。
        //所以综上所述，要使用位运算来避免溢出问题，同时循环32次。
        //因为一共只有32位，所以时间复杂度和空间复杂度都是O(1)。
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
